# Моментальные снимки и восстановление к ним: Linux+BTRFS+Snapper
*Как перестать бояться экспериментировать с системой*

> жена: ложись сегодня спать пораньше
> я: /качая арч линукс/ ок

https://bash.im/quote/451399


TODOS:
+ [ ] Отделить лирику от шагов
+ [ ] Причесать лирику
+ [ ] Надо чтобы скрипт скачивался одной строкой запуска в live antergos/manjaro

## Установка по SSH

1. Arch можно ставить через SSH ([1](https://unix.stackexchange.com/questions/352139/how-to-setup-ssh-access-to-arch-linux-iso-livecd-booted-computer), [2](https://wiki.archlinux.org/index.php/Install_from_SSH_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9))) .
```bash
# выполняется под root потому что ничего другого в Arch ISO нет
passwd manjaro
systemctl start sshd.service
```
2. C manjaro чуть по-другому. Там надо менять пароль и подключаться под пользователем `manjaro`. 
```bash
# от имени пользователя "manjaro"
sudo passwd manjaro
sudo systemctl start sshd.service
```
3. Проверить адрес: *TODO: Проверить, можно ли правильнее*
```bash
ip -4 address | grep global
```
4. После этого можно цепляться к SSH, я делаю это через WSL, а не putty *TODO: обосновать*
5. Строгая проверка хоста со стандартным ISO невозможна *TODO: проверить*. Поэтому `StrictHostKeyChecking=no` и `UserKnownHostsFile=/dev/null`:
```bash
ssh root@192.168.0.xxx -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
```

## Скачать скрипты

Не забывать делать push в репозиторий перед скачиванием!

```bash
wget https://github.com/speshuric/karramba/tarball/master -O - | tar xz 
mv speshuric-karramba-* karramba 
cd ./karramba/scripts
```

Shorter: 
```bash
wget https://git.io/fjRjE -O - | tar xz 

mv speshuric-karramba-* karramba 
cd ./karramba/scripts
./1.init-install.sh
```

From gitlab:
```
wget https://gitlab.com/speshuric/karramba/-/archive/master/karramba-master.tar.gz -O - | tar xz
mv karramba-* karramba 
cd ./karramba/scripts
./1.init-install.sh
```

From gitlab:
```
wget https://gitlab.com/speshuric/karramba/-/archive/master/karramba-master.tar.gz -O - | tar xz
mv karramba-* karramba 
cd ./karramba/scripts
./1.init-install.sh
```

Through `git clone`:
```
git clone https://gitlab.com/speshuric/karramba.git
cd ./karramba/scripts
./1.init-install.sh
```



## Important!!! Всё ниже шлак и черновики

Так! Короче! Я передумал! Ставить будем не ебанутыми скриптами, а через ansible. 

Краткая идея: есть инсталляционная флешка или образ arch или manjaro. Грузимся, запускаем сеть, даём ssh и... И всё остальное делает снаружи playbook ansible.

Засады и примечания:

**Засада** Ansible надо поставить на хост. Хост - винда. 

Решение: 
1. Лучше использовать WSL
2. Ставим [MSYS2](https://www.msys2.org/) а в нём уж ставим ansible
3. Скрипт установки ansible берем [тут - file-python3-install-ansible-on-msys2-sh](https://gist.github.com/DaveB93/db94a6b310e08c928c0778f766562ab0#file-python3-install-ansible-on-msys2-sh)
4. Если в путях по умолчанию есть пробелы, то нужен явный конфигурационный файл 

Решение взято [тут](https://superuser.com/questions/1255634/install-ansible-in-windows-using-git-bash)

**Засада** Ansible расчитан на работу с ssh-ключами. 

Это правильно и разумно, безусловно. Только вот засада - в штатном дистрибутиве нет ключа. Варианты решения:
1. Изменять все дистрибутивы. Ну... так себе перспектива.
2. Просто хардкодить пароль. Ну... 
3. Передавать его через vault - лучше, но еще не айс
4. 3+Первым шагом подсунуть ssh-ключ.

Кажется самый разумный - 3, но я еще посмотрю.

Что и как надо делать:
1. Если ругается `to use the 'ssh' connection type with passwords, you must install the sshpass program`, то надо установить `sshpass` (`pacman -S sshpass` или `apt-get install sshpass`)
2. ...

**Засада** Ansible не работает с путями home содержащими пробелы

[баг](https://github.com/ansible/ansible/issues/47022), [баг](https://github.com/ansible/ansible/issues/32166)

Решение не окончательное: 
меняем 
```python
                b_args = (b"-o", b"ControlPath=" + to_bytes(self.control_path % dict(directory=cpdir), errors='surrogate_or_strict'))
```
на 
```python
                b_args = (b"-o", b"ControlPath=" + to_bytes("\"" + (self.control_path % dict(directory=cpdir)) + "\"", errors='surrogate_or_strict'))
```

Это не очень правильно. 

**Засада** упс! "Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this.  Please add this host's fingerprint to your known_hosts file to manage this host"

И при каждой установке он может быть разный.



**Информация** Предшественники

Я, конечно, не то чтобы первый додумался до этой идеи. Ну точнее так: я не нашёл готового решения, но многое подсмотрел.

1. Arch можно ([1](https://unix.stackexchange.com/questions/352139/how-to-setup-ssh-access-to-arch-linux-iso-livecd-booted-computer), [2](https://wiki.archlinux.org/index.php/Install_from_SSH_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9))) ставить с SSH.
2. C manjaro чуть по-другому. Там надо менять пароль и подключаться под юзером `manjaro`. 
```
$ sudo passwd manjaro
$ sudo systemctl start sshd.service
```
3. Идея развертываться Ansible тоже уже протоптана: 
    - [Тут](https://github.com/pigmonkey/spark) чувак делает постинсталл на Ansible (но мне-то надо с бутстрапа и с партиций) .https://pig-monkey.com/2015/12/spark/
    - [Тут](https://github.com/dharmab/ansible-archlinux/tree/master/roles/archlinux) вообще что-то левое
    - Прикольная [дискусия](https://www.reddit.com/r/archlinux/comments/2r2kl9/how_do_you_automate_your_reinstalls/)
    - Но таки надо отметить, что playbook'и которые я нашёл &ndash; это постинсталлы. А мне нужно разметку диска и всё такое.
4. В ansible есть и работа с дисками и пакман и вообще, но я подозреваю, что писать плагин придётся.

-----


## TLDR

- Почему btrfs подходит для решения этой задачи
- Что кроме FS еще нужно для решения (утилита Snapper в данном случае)
- Как настроить один или несколько разделов btrfs для утилиты Snapper
- Как настроить Snapper
- Почему такой странный набор

Описаны некоторые моменты установки linux, настройки раздела btrfs и утилиты Snapper с указанием основных известных мне граблей. Ну и немного соплей и рассуждений.

## С чего всё началось

С 2011 года я использовал разные дистрибутивы linux, в основном Ubuntu (Mint, Xubuntu и т.п.) и OpenSUSE. Совсем не по душе пришлись Fedora/CentOS. Не сжился (не осилил) с gentoo и с arch.

Когда я только начинал работать с linux, как с десктопной ОС, это был непрекращающийся поток багов и боли. Всё отваливалось. И на железе и в виртуальной машине. Хорошо было бы это списать на кривые руки, но нет, это действительно были разные неприятные ошибки. Беда в том, что попытки исправить что-то одно раздражающее в теме запросто приводят к тому, что Xorg или Wayland не грузится совсем и давай, дружок, исправляй в консоли. А для того чтобы исправить шрифт по умолчанию запросто может оказаться, что требуется исправление в 4 местах и то, процессы запускаемые с sudo отображаются криво. Причем всё это еще и замаскировано хитро. Типа btrfs в целом работает, но только не на тонких LVM-томах. Или conky (это мониторинг десктопный такой) работает, но чтобы корректно обновлялся на xfce нужно потанцевать с бубном. Всё в отдельности работает, но не вместе. Или после обновления пакета A отваливается взаимодействие пакетов B и С.

## Перечисление проблем - под кат

- ШГ. Шрифты года до 2014 били палкой по глазам, а установка infinality patch обязательно ломала какую-нибудь мелочь. Обязательно конфликтовали PPA, но они были нужны потому что в основных репозиториях было старье или в принципе не было ("Ой, ну мы такие все свободные, не можем же мы пакеты с MIT лицензией использовать"). Ключевая проблема была в патентах, и, по мере их протухания ситуация в целом становится лучше. Но проблема была не только в патентах, но и в конкретных кейсах использования. Firefox под Gnome - OK, а под KDE - пшшшш. Главная страница google - отлично, а, например, старый дизайн Хабра только после шаманских плясок. Шрифты в OpenSuse настроил? А вот то, что запускается в sudo - использует свои, ну и так далее. Но, повторюсь, постапенно всё донастраивается: программы, настройки, шрифты. А заодно и Hi-DPI мониторы делают сглаживание менее критичным (а вот зато масштабирование - боль)
- В Ubuntu традиционно почти каждый релиз ломал переключение раскладок, особенно по Ctrl-Shift и Alt-Shift, а в OpenSuse ломалось всё с самой установки. В linux баян с раскладками [длится](https://bugs.freedesktop.org/show_bug.cgi?id=865) с 2004 года.
- Skype умирал и воскресал несколько раз.

## ***

С годами ситуация стала проще, пользовательские "свежие" дистрибутивы стали стабильнее, красивее, но иногда "нет-нет да и да".

Я, возможно, сгущаю краски, но отстрелить себе в linux можно всё и быстро. Никто не запретит. И это не бага. Это главная фича и обратная сторона вседозволенности. Ты можешь делать что угодно, но тебе и принимать отвественость за решение. Обвинить "криворуких рэдмондовцев" не получится. Это создаёт очень интересное распределение того, как по-разному работают утилиты в Linux и Windows. Например, в linux можно работать с диском (блочным устройством), как с плоским файлом - тупо берем и пишем в него, например. А в Windows это можно, но скрыто и защищено.

Но есть с этой вседозволенностью один нюанс: хочется, чтобы всегда был "план Б". Я в общем-то не против экспериментов, падений и восстановлений, но хочется, чтобы из-за исправления некрасивой буквы ["Г" в шрифте](https://bugs.launchpad.net/ubuntu-font-family/+bug/784549) не пришлось переустанавливать ОС, а можно было просто вернуться. И ведь есть, есть уже придуманное решение. Под виндой - системные точки восстановления. Под macOS - Time Machine. И даже есть похожий механизм в Linux, например есть моментальные снимки в LVM и в COW-файловых системах, в частности btrfs. Но с этими моментальными снимками не всё так просто.

Многие используют для откатов моментальные снимаки LVM. Это бэкапы не уровня файловой системы, а уровня раздела. Это значит, что нет возможности сказать "а вот этот файлик мне в снимке не нужен". Подтома (subvolume) btrfs в этом гораздо гибче, поэтому я пользуюсь ими.

Есть ровно один известный мне дистрибутив, в котором есть "из коробки" управление этими "точками восстановления": OpenSUSE - в ней есть утилита snapper, диспетчер этих точек восстановления, и достаточно специфичное разбиение раздела. Но этот дистрибутив не нравится мне почти всем остальным (дурацкий YaST, странный zipper, не всегда стабильная работа, убогий рендеринг шрифтов, множество недоработок). Теоретически можно установить snapper и в других ОС, но в них нет автоматических снимков при установке/удалении программ, да и btrfs разбит на подтома неоптимально - это важно, так как в btrfs по умолчанию все операции записи copy-on-write, а это достаточно ресурсоёмко. Теоретически можно обойтись без snapper: например полумертвый проект apt-btrfs-snapshot или самому запилить, но тогда придётся вручную делать многие операции. Так я в общем-то и поступил, но оставалась какая-то заноза неудовлетворенности.  

**Важно:** снимки подтомов btrfs не заменяют бэкапы. Вернуться к снимку вы можете если снимок корректен, если файловая система не развалилась, если носитель работоспособен, если не перепутаете снимки, если не удалите их случайно. Наоборот тоже не работает: перед обновлением одного маленького пакета делать бэкап всего раздела как-то расточительно. В общем, снимок не бэкап, а бэкап не снимок.

## Почему и как я вернулся к snapper

В какой-то день в Ubuntu опять сломалось переключение раскладок. Это уже традиция. Ну сколько же можно! Я решил лечить насморк гильотиной. Я решил попробовать arch-based дистрибутивы и... и оказалось, что arch не настолько сложный в установке, что есть кучка "дочерних" дистрибутивов, которые совсем просто ставятся, оказалось что pacman не хуже apt, AUR точно даст фору laucnhpad'у, а уж документация у Arch самая крутая из всех дистрибутивов. Теперь у меня большая часть установок живет на Manjaro, часть на поделках типа antergos, а парочка на "родном" arch. Если кто не пробовал это семейство, то вот краткое описание нескольких дистров этой семьи.

### Arch

Специфичный, однако, дистрибутив. Установка в стиле DIY: в документации подробно описаны шаги - команды в консоли, конечно, ничего сверхсложного, но это не "далее-далее-далее". Rolling, то есть никакой фиксации версий нет и в помине. Весьма необычный пакетный менеджер `pacman`, но необычный - не значит плохой. Пакетов в даже в официальных репозиториях субъективно больше, чем в Debian/Ubuntu/OpenSuse/CentOS и прочих, а при подключении AUR (это неофициальные **пользовательские** репозитории) - доступно вообще всё что можно придумать. "Стабильные" пакеты вчера из git, а "нестабильные", обновляются чуть ли не тогда, когда разработчик push в git делает. А то и раньше. То есть на "энтерпрайзную стабильность" тут надеяться как-то опреметчиво. А с другой стороны - у этого дистрибутива сильнейшее квалифицированное комьюнити и он подкупает количеством и качеством документации и лёгким решением всех моих предыдущих головняков. Как-то сложилось, что мне оказалось проще разобраться и починить, чем ждать когда же уважаемые дистрибутивописатели соизволят починить.
Для облегчения установки есть шаблоны скриптов установки.

### Клоны-установщики (Anarchy linux, Antergos и подобные)

RIP Antergos

В семействе Arch есть несколько дистрибутивов, которые сложно назвать дистрибутивами. Live образ, темы графических оболочек и графический установщик - вот и весь тот дистрибутив. У одних установщик получше, у других похуже. С другой стороны - примерно это и надо для комфортной установки Arch: установка больше не похожа на смесь призыва злых духов и приготовления хлеба, если есть только молоток, нож и лопата. После установки такой дистрибутив живет почти-почти как обычный Arch, а значит применима его богатая документация, хотя в Arch постоянно подчеркивают, что если ты поставил из установщика и не понял, как и что он сделал, то это не "тру арч уэй".

Надо учитывать, что такие проекты пилятся совсем небольшой группой товарищей, а это значит:
- Баги и хотелки могут висеть долго-долго. У авторов может на них не хватать времени.
- Проект вообще может в любой момент свернуться.
- Установщики обычно изнутри достаточно глюкавые, а cnchi из Antergos еще и при установке он обновляется чуть ли не с git. Иногда из-за этого часть зеркал для установки используются некорректно.
- Если хочется установить хоть чуть-чуть по-другому, то установщик будет больше мешать, чем помогать.

### Manjaro

Этот дистрибутив чуть дальше от Arch. Да, у него тоже есть Live образ, тоже свой установщик (даже два! Calamares и manjaro-architect), но у него свои репозитории пакетов. Не Arch'евские. По факту там большинство пакетов абсолютно те же что и в Arch, но формально это другой репозиторий. То есть документация Arch может подойти, а может и нет. "Из коробки" оформление симпатичное. Команда разработки не такая небольшая, как в Аntergos, но всё равно bus-factor у неё очень небольшой. Мне нравятся в нем темы оформления, поэтому часто я ставлю его, но вручную, потому что интерактивный установщик не умеет делать так, как я хочу.

## Замечания по установке.

Я не буду описывать установку пошагово. Для всех разных дистрибутивов, один из которых Arch, это невозможно. Я лишь укажу несколько ключевые на мой взгляд моменты.
Еще момент. Linuх я выбираю не потому что стабилен, а потому что обычно можно починить. Често говоря - граблей на этом пути много, и не существует "полной карты граблей".

### Деление на разделы

Нам надо, чтобы корневой раздел был Btrfs. Это сразу влечет несколько следствий.
1. Файл подкачки (swap file) на Btrfs [лучше не размещать](https://wiki.archlinux.org/index.php/Swap#Swap_file). Либо не используйте swap вообще, либо по старинке - отдельный раздел.
2. Если используется GPT-диск на BIOS, то нужно создаёть раздел с `bios_grub`. Например, установщик Antergos, если делать разбивку вручную, заботливо предупреждает **"GRUB требует, чтобы загрузочный раздел в BIOS системах содержал файл core.img из-за отсутствия пропуска после таблицы в GPT дисках. Cnchi создаст этот загрузочный раздел BIOS за вас."** Подробнее [тут](https://wiki.archlinux.org/index.php/GRUB_%28%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9%29#.D0.A2.D1.80.D0.B5.D0.B1.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_GRUB2-BIOS_.D0.BA_GPT). Если не вручную, то раздел с `bios_grub` стоит сделать самому. Размер 1-2 MiB вполне достачтоно
3. На UEFI понадобится [EFI System Partition](https://wiki.archlinux.org/index.php/EFI_System_Partition). Документацией Arch рекомендуется 512 MiB или больше, Manjaro создаёт 300 MiB.
4. `/boot` лучше вынести в отдельный раздел. Тут ситуация такая: документация GRUB [пишет](https://wiki.archlinux.org/index.php/GRUB_%28%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9%29#.D0.92.D1.8B.D0.B1.D0.BE.D1.80_.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.B0) "Если загрузчик в состоянии прочесть корневой раздел, создание отдельного раздела для `/boot` не нужно и не рекомендуется.". Grub загружается с btrfs, но в большинстве систем при этом пишет "error: sparse file not allowed", а это как [пишут](https://forum.manjaro.org/t/features-from-opensuse/47148) - известная совместная бага btrfs и grub2. В OpenSUSE, как для "драйвера" btrfs, есть патч, остальным приходится крутиться. Для себя я решил, что ну его к лешему - `/boot` не очень большой и его можно на ext4 нормально держать, меняется не так активно, как root-раздел, соответственно без моентальных снимков переживу. Заодно в тот же раздел стоит положить live-образ на случай всяких непредвиданностей. В общем, я на `boot` оставил 4 GiB.
5. `/home` удобнее держать на отдельном разделе.

У меня 24 GiB RAM, я выделяю swap размером с память, и получается, что с диска на swap+ESP+boot уйдёт 24 + 0.5 + 4 = 28.5 GiB. Эм... это как бы даже больше, чем обычно заполненый root-раздел. Ну да ладно, у меня SSD на 1,6 TiB (бе-бе-бе), как-нибудь смирюсь с такими тратами.

Итак, у меня несколько дисков, часть из них hdd, часть ssd, а есть еще диск с дистрибутивом, с которого загрузились. Для того, чтобы посмотреть, какие диски у нас есть использую `lsblk`. Так выглядит в VM
```
$ lsblk                                             
NAME  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
loop0   7:0    0  1.8G  1 loop /run/archiso/sfs/root-image
sda     8:0    0  128G  0 disk
sr0    11:0    1  1.9G  0 rom  /run/archiso/bootmnt
```

Тут в установке есть одна интересная хитрость. Я активно пользуюсь несколькими ОС, в том числе не могу снести Windows. У меня в системном блоке несколько HDD и SSD. И так как мне всё равно придётся настраивать мультизагрузку, а Linux вполне переживает загрузку по очереди то в VM, то в железе, то есть смысл подключить **физический** диск (SSD) в VirtualBox и там уже устанавливать. Плюсов тут несколько:
- Пока устанавливается ОС можно ~~подро~~ спокойно заниматься своими делами.
- Если что-то пошло не так, можно загуглить проблему или заранее подготовить скрипты.
- Установщик не имеет шансов запоганить загрузку остального зоопарка. Однако, после установки придётся настраивать мультизагрузку, но с этим проще бороться, когда лишь одна из трёх систем не грузится, а не когда ничего не работает.
- Загрузка и установка с образа на HDD/SSD быстрее чем с флэшки и уж тем более с DVD (кто помнит, что такое DVD в 2018 году?).

Главный минус - нужно будет немного повозиться с GRUB, чтобы в виртуалке запускались одни драйвера и модули ядра, а в реальной машине другие и всё это не сломалось при следующем обновлении. Ой. Стоп. "Немного повозиться" - кого я тут обманываю? На самом деле придётся перечитать хорошую горку документации и поэкспериментировать. Как говорят на лекциях "дальнейшее доказательство оставляю в качестве несложного упражнения".

Добрые советы:
- При работе с физическим диском VirtualBox в Windows скорее всего придётся запускать с административными правами.
- НЕ ВКЛЮЧАЙТЕ кеширование IO диска в настройках виртуальной машины. Если придётся снимать процесс VM, то есть неплохие шансы убить файловую систему.
- НЕ ИСПОЛЬЗУЙТЕ сохранение состояния и снимки. Так тоже можно убить файловую систему (забыл, что виртуальную машину не выключил, а засуспендил, загрузился с диска и привет - так я однажды и сделал).
- Для SSD не забыть сказать диску, что он SSD
- В случае такой конфигурации нужно будет отдельно устанавливать некоторые драйвера (wifi, например) после установки или явно указав при установке.

Дальше я считаю, что тот самый диск, на который ставим систему - sda и что на нем нет и не будет других ОС. Для однократной разбивки можно было бы пользоваться `gparted` или `cfdisk`/`gfdisk`, но я хочу сделать воспроизводимую установку. Так что `parted`.

1. Два раза проверяю, что диск именно тот. Мы сейчас собираемся его очистить.
2. На диске создаём таблицу разделов **gpt**.
3. Создаём раздел с `bios_grub`.
4. swap (примерно с память размером)
5. boot - ext4 - 4 ГБ, хотя это весьма избыточно
6. root - btrfs - именно тут будет работать snapper
7. home - btrfs
8. Заскриптовано [тут](./scripts/init-disk.sh)


Если устанавливается чистый Arch или manjaro architect, то дальше имеет смысл создать подтома, а если графический инсталлятор, то ставим ОС. Графические инстанняторы (что [cnchi](https://github.com/Antergos/Cnchi/issues/812), что calamares, что [manjaro-architect](https://github.com/Chrysostomus/manjaro-architect/issues/248)) тупые и не смогут нормально установиться, поэтому проще потом поправить. Правда, manjaro-architect можно комбинировать с установкой из командной строки, но требуется в нем разобраться.

### Деление на подтома (subvolumes)

Ключевой момент в использовании btrfs для снимков - управление подтомами. Подтом - это почти как папка, но за счет copy-on-write, можно мгновенно создать новый подтом, который будет снимком другого. При записи в исходный или в новый подтом они конечно "разойдутся". На этом, собственно, вся магия и основана.
Но COW - дорогой механизм. Во многом из-за него btrfs регулярно [проигрывает](https://www.phoronix.com/scan.php?page=article&item=linux418-nvme-raid&num=2) другим ФС. Причем, на быстрых SSD разрыв может быть существенным. Плюс в ОС часть каталогов не следует включать в снимки:
* Логи - если что-то пошло не так при операциях со снимками, то логи должны быть "сквозными"
* Рабочие данные программ (базы данных, ВМ и т.п.) - их не надо восстанавливать. Их резервное копирование лучше делать отдельной задачей. В этих каталогах лучше еще и отключить COW.
* Программы, установленные в opt - непонятно, можно ли их "просто откатить".

Примерно по такой логике и шли создатели OpenSUSE: часть каталогов ОС исключены из механизма снимков - для них созданы отдельные подтома. До января 2018 у них в дистрибутиве была ["развесистая"](https://en.opensuse.org/SDB:BTRFS#Default_Subvolumes) структура подтомов (был хитроумный зоопарк в `/var`), но потом она упрощена до отдельных томов для:
* `/boot/grub2/i386-pc`, `/boot/grub2/x86_64-efi`, `/boot/grub2/powerpc-ieee1275`, `/boot/grub2/s390x-emu`
* `/home` (впрочем, его и `/boot` мы вынесли на другой раздел)
* `/opt`
* `/root`
* `/srv`
* `/tmp`
* `/usr/local`
* `/var` - у этого подтома еще и COW отключен

Создадим аналогичную структуру на нашем корневом разделе.

```
Тут будет скрипт
```
### Подтома для снимков

Думаете это всё? Неееет. Стрижка только началась.

### Установка ОС

У
### Установка ПО

### Настройка


## Установка snapper в живую систему


#### Откуда дровишки

У antergos свой установщик [cnchi](https://github.com/Antergos/Cnchi), написанный с 0. На python. Так вот установщик очень активно развивается и допиливается. Всё бы хорошо, но при установке он обновляется чуть ли не с git. В некоторых случаях при этом обновлении часть зеркал для устаноки используются некорректно. Я пока не стал бороться с обновлениями, а просто решил использовать заведомо шустрые зеркала.

- [Как обновлять список зеркал](https://antergos.com/wiki/uncategorized/how-to-choose-your-mirrors-before-installing-antergos/), на [русском](https://antergos.com/wiki/ru/uncategorized/how-to-choose-your-mirrors-before-installing-antergos/) не смотрите, сломаете глаз
- [Как выбирать быстрые зеркала](http://unixa.ru/korotko-o-glavnom-./arch-rankmirrors-ili-delaem-mirrorlist-aktualnyim-i-byistryim.html)
- [Оригинальная документация Arch](https://wiki.archlinux.org/index.php/mirrors)

Проблемы:
- в примере "Как обновлять список зеркал" у меня не не было файла `antergos-mirrorlist.pacnew`
- `rankmirrors` с `antergos-mirrorlist` не заработал. Надо проверить, как ранжируются зеркала в `cnchi`

Скрипты:
- [set-mirrors.sh](../scripts/set-mirrors.sh) - копирует заранее созданные файлы `antergos-mirrorlist` и `mirrorlist`
- [update-mirrors.sh](../scripts/set-mirrors.sh) - попытка автоматизированно получить самые быстрые зеркала.

Не забыть:
- Установить `chmod +x` скриптам
- При запуске не пересортировывать зеркала.
- [Yandex](https://yandex.ru/) - спасибо за ультрабыстрые зеркала репозиториев
- Посмотреть, можно ли в cnchi оптимизировать загрузку и отремонтировать прогресс-бар

#### Прочие мелочи

- `cfdisk` - терминальная альтернатива `gparted`
- `lsof` - что ггде открыто
- swap-файл на btrfs не положить. Поэтому - раздел.
- без boot можно обойтись. теоретически.


##### Жирные пакеты в AUR

Пакеты в AUR иногда большие. Очень большие. А `/tmp` в памяти и ограничен. [Опции](https://archlinuxarm.org/forum/viewtopic.php?f=57&t=8812):
- Увеличить `/tmp`
- Собирать не в tmp

##### chmod+x в Windows

При написании этих скриптов возникла проблемочка: писал я их частично в Windows, а в этом случае они прилетали в репозиторий не как выполняемые файлы.

Решение
```
> git add .
> git ls-files --stage
100644 012c4ba239ecdbd15c70c05b9306c32175dc8c5c 0       file.sh
> git update-index --chmod=+x file.sh
> git commit -m "executable"
[master c6e8134] executable
 1 files changed, 1 insertions(+), 1 deletion(-)
 mode change 100644 => 100755 scripts/file.sh
> git ls-files --stage
100755 012c4ba239ecdbd15c70c05b9306c32175dc8c5c 0       file.sh
```

##### Установка wifi
https://forum.manjaro.org/t/broadcom-bcm4360-wifi-not-working/2141



- [Как обновлять список зеркал](https://antergos.com/wiki/uncategorized/how-to-choose-your-mirrors-before-installing-antergos/), на [русском](https://antergos.com/wiki/ru/uncategorized/how-to-choose-your-mirrors-before-installing-antergos/) не смотрите, сломаете глаз
- [Как выбирать быстрые зеркала](http://unixa.ru/korotko-o-glavnom-./arch-rankmirrors-ili-delaem-mirrorlist-aktualnyim-i-byistryim.html)
- [Оригинальная документация Arch](https://wiki.archlinux.org/index.php/mirrors)


