# Моментальные снимки и восстановление к ним: Linux+BTRFS+Snapper
*Как перестать бояться экспериментировать с системой*

TODOS:
+ [ ] Отделить лирику от шагов
+ [ ] Причесать лирику
+ [ ] Надо чтобы скрипт скачивался одной строкой запуска в live antergos/manjaro

## TLDR

- Почему btrfs подходит для решения этой задачи
- Что кроме FS еще нужно для решения (утилита Snapper в данном случае)
- Как настроить один или несколько разделов btrfs для утилиты Snapper
- Как настроить Snapper
- Почему такой странный набор

Описаны некоторые моменты установки linux, настройки раздела btrfs и утилиты Snapper с указанием основных известных мне граблей. Ну и немного соплей и рассуждений.

## С чего всё началось

С 2011 года я использовал разные дистрибутивы linux, в основном Ubuntu (Mint, Xubuntu и т.п.) и OpenSUSE. Совсем не по душе пришлись Fedora/CentOS. Не сжился (не осилил) с gentoo и с arch. 

Когда я только начинал работать с linux, как с десктопной ОС, это был непрекращающийся поток багов и боли. Всё отваливалось. И на железе и в виртуальной машине. Хорошо было бы это списать на кривые руки, но нет.

<details>
  <summary>Перечисление проблем</summary>
### ШГ

Шрифты били палкой по глазам, а установка infinality patch обязательно ломала какую-нибудь мелочь. Обязательно конфликтовали PPA, но они были нужны потому что в основных репозиториях было старье или в принципе не было ("Ой, ну мы такие все свободные, не можем же мы пакеты с MIT лицензией использовать"). В Ubuntu традиционно почти каждый релиз ломал переключение раскладок, особенно по Ctrl-Shift и Alt-Shift, а в OpenSuse ломалось всё с самой установки. Попытки исправить что-то одно раздражающее в теме запросто приводят к тому, что Xorg или Wayland не грузится совсем и давай, дружок, исправляй в консоли. А для того чтобы исправить шрифт по умолчанию запросто может оказаться, что требуется исправление в 4 местах и то, процессы запускаемые с sudo отображаются криво. 

Со временем некоторые проблемы постепенно уходят - с шрифтами, их сглаживанием и хинтингом ситуация становится всё лучше и лучше.

### раскладка
(в linux баян с этим [длится](https://bugs.freedesktop.org/show_bug.cgi?id=865) с 2004 года)

### Skype

Он умирал несколько раз. 

Причем всё это еще и замаскировано хитро. Типа btrfs в целом работает, но только не на тонких LVM-томах. Или conky (это мониторинг десктопный такой) работает, но чтобы корректно обновлялся на xfce нужно потанцевать с бубном. Всё в отдельности работает, но не вместе. Или после обновления пакета A отваливается взаимодействие пакетов B и С.

</details>

Я, возможно, сгущаю краски, но отстрелить себе в linux можно всё и быстро. Никто не запретит. И это не бага. Это главная фича и обратная сторона вседозволенности. Ты можешь делать что угодно, но тебе и принимать отвественость за решение. Обвинить "криворуких рэдмондовцев" не получится. Это создаёт очень интересное перераспределение того, что умеют утилиты в Linux и Windows. В Windows 

Но есть с этой вседозволенностью один нюанс: хочется, чтобы всегда был "план Б". Я в общем-то не против экспериментов, падений и восстановлений, но хочется, чтобы из-за исправления некрасивой буквы ["Г" в шрифте](https://bugs.launchpad.net/ubuntu-font-family/+bug/784549) не пришлось переустанавливать ОС, а можно было просто вернуться. И ведь есть, есть уже придуманное решение. Под виндой - системные точки восстановления. Под macOS - Time Machine. И даже есть похожий механизм в Linux, например есть моментальные снимки в LVM и в COW-файловых системах, в частности btrfs. Но с этими моментальными снимками не всё так просто.

Моментальные снимаки LVM. Это бэкапы не уровня файловой ситемы, а уровня раздела. Это значит, что нет возможности сказать "а вот этот файлик мне в снимке не нужен". Подтома (subvolume) btrfs в этом гораздо гибче, поэтому я пользуюсь ими.

Есть ровно один известный мне дистрибутив, в котором есть "из коробки" управление этими "точками восстановления": OpenSUSE - в ней есть утилита snapper, диспетчер этих точек восставновления, и достаточно специфичное разбиение раздела. Но этот дистрибутив не нравится мне почти всем остальным (дурацкий YaST, странный zipper, нестабильная работа, убогий рендеринг шрифтов, множество недоработок). Теоретически можно установить snapper и в других ОС, но в них нет автоматических снимков при установке/удалении программ, да и btrfs разбит на подтома неоптимально - это важно, так как в btrfs по умолчанию все операции записи copy-on-write, а это достаточно ресурсоёмко. Теоретически можно обойтись без snapper: например полумертвый проект apt-btrfs-snapshot или самому запилить, но тогда придётся вручную делать многие операции. Так я в общем-то и поступил, но оставалась какая-то заноза неудовлетворенности.  

**Важно:** эти снимки не заменяют бэкапы. Вернуться к снимку вы можете если снимок корректен, если файловая система не развалилась, если носитель работоспособен, если не перепутаете снимки, если не удалите их случайно. Наоборот тоже не работает: перед обновлением одного маленького пакета делать бэкап всего раздела как-то расточительно. В общем, снимок не бэкап, а бэкап не снимок.

## Почему и как я вернулся к snapper

В какой-то день в Ubuntu опять сломалось переключение раскладок. Ну сколько же, можно! Я решил лечить насморк гильотиной. Я решил попробовать arch-based дистрибутивы и... и оказалось, что arch не настолько сложный в установке, что есть пара "дочерних" дистрибутивов, которые совсем просто ставятся, оказалось что pacman не хуже apt, а AUR точно даст фору laucnhpad'у, а документация у Arch самая крутая из всех дистрибутивов. Теперь у меня часть установок живет на Manjaro, часть на antergos, а парочка на "родном" arch. Если кто не пробовал это семейство, то 

### Arch

Специфичный, однако, дистрибутив. Установка в стиле DIY: в документации подробно описаны шаги, ничего сверхсложного, но это не "далее-далее-далее". Rolling, никакой фиксации версий нет и в помине. Весьма необычный пакетный менеджер pacman, но специфичный - не значит плохой. Пакетов в даже в официальных репозиториях субъективно больше, чем в Debian/Ubuntu/OpenSuse/CentOS и прочих, а при подключении AUR (это неофициальные пользовательские репозитории) - доступно вообще всё что можно придумать. "Стабильные" пакеты вчера из git, а "нестабильные", обновляются чуть ли не тогда, когда разработчик push в git делает. А то и раньше. То есть на "энтерпрайзную стабильность" тут надеяться как-то опреметчиво. А с другой стороны - у этого дистрибутива сильнейшее квалифицированное комьюнити и он подкупает количеством и качеством документации и лёгким решением всех моих предыдущих головняков.
Для облегчения установки есть шаблоны скриптов установки. 

### Antergos

Аntergos - сложно даже назвать отдельным дистрибутивом. Live образ, темы графических оболочек и графический установщик (cnchi). С другой стороны - примерно это и надо для комфортной установки Arch: установка больше не похожа на смесь призыва злых духов и приготовления хлеба, если есть только молоток, нож и лопата. После установки antergos живет почти-почти как обычный Arch, а значит применима его богатая документация. 
Надо учитывать, что проект пилится совсем небольшой группой товарищей, а это значит:
- Баги и хотелки могут висеть долго-долго. У автором может на них не хватать времени.
- Проект вообще может в любой момент свернуться.
- cnchi изнутри достаточно глюкавый, а при установке он обновляется чуть ли не с git. Иногда из-за этого часть зеркал для установки используются некорректно. 

Из плюсов Antergos:
- Он благодарит [JetBrains](https://www.jetbrains.com/)
- Драйвера гостя для VirtualBox встают сразу же (всегда, стабильно). Это удобно для экспериментов.
- Шрифты - нормально выглядят.
- GNOME с плоской темой выглядит замечательно.
- Всё свежее (ну как и везде в Arch). 

Но. оказалось, что и здесь есть... эм... нюансики:

### Manjaro

Этот дистрибутив чуть дальше от Arch. Да, у него тоже есть Live образ, тоже свой установщик (даже два! Calamares и manjaro-architect), но у него свои репозитории пакетов. Не Arch'евские. По факту там большинство пакетов те же что и в Arch, но формально это другой репозиторий. То есть документация Arch может подойти, а может и нет. "Из коробки" оформление симпатичное. Команда разработки не такая небольшая, как в Аntergos, но всё равно bus-factor у неё очень небольшой. 

## Замечания по установке.

Я не буду описывать установку пошагово. Для трёх разных дистрибутивов, один из которых Arch, это невозможно. Я лишь укажу несколько ключевых моментов.
Нам надо, чтобы корневой раздел был Btrfs. Это сразу влечет несколько следствий. 
1. Файл подкачки (swap file) на Btrfs [лучше не размещать](https://wiki.archlinux.org/index.php/Swap#Swap_file). Либо не используйте swap вообще, либо по старинке - отдельный раздел.
2. Если используется GPT-диск на BIOS, то нужно создаёть раздел с `bios_grub`. Например, установщик Antergos, если делать разбивку вручную, заботливо предупреждает **"GRUB требует, чтобы загрузочный раздел в BIOS системах содержал файл core.img из-за отсутствия пропуска после таблицы в GPT дисках. Cnchi создаст этот загрузочный раздел BIOS за вас."** Подробнее [тут](https://wiki.archlinux.org/index.php/GRUB_%28%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9%29#.D0.A2.D1.80.D0.B5.D0.B1.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_GRUB2-BIOS_.D0.BA_GPT). Если не вручную, то раздел с `bios_grub` стоит сделать самому. Размер 1-2 MiB вполне достачтоно
3. На UEFI понадобится [EFI System Partition](https://wiki.archlinux.org/index.php/EFI_System_Partition). Документацией Arch рекомендуется 512 MiB или больше, Manjaro создаёт 300 MiB.
4. `/boot` лучше вынести в отдельный раздел. Тут ситуация такая: документация GRUB [пишет](https://wiki.archlinux.org/index.php/GRUB_%28%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9%29#.D0.92.D1.8B.D0.B1.D0.BE.D1.80_.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.B0) "Если загрузчик в состоянии прочесть корневой раздел, создание отдельного раздела для `/boot` не нужно и не рекомендуется.". Grub загружается с btrfs, но в большинстве систем при этом пишет "error: sparse file not allowed", а это как [пишут](https://forum.manjaro.org/t/features-from-opensuse/47148) - известная совместная бага btrfs и grub2. В OpenSUSE, как для "драйвера" btrfs, есть патч, остальным приходится крутиться. Для себя я решил, что ну его к лешему - `/boot` не очень большой и его можно на ext4 нормально держать, меняется не так активно, как root-раздел, соответственно без моентальных снимков переживу. Заодно в тот же раздел стоит положить live-образ на случай всяких непредвиданностей. В общем, я на `boot` оставил 4 GiB.

При моих 24 GiB RAM получается, что с диска на swap+ESP+boot уйдёт 24 + 0.5 + 4 = 28.5 GiB. Эм... это как бы даже больше, чем обычно заполненый root-раздел.
 

#### Откуда дровишки

У antergos свой установщик [cnchi](https://github.com/Antergos/Cnchi), написанный с 0. На python. Так вот установщик очень активно развивается и допиливается. Всё бы хорошо, но при установке он обновляется чуть ли не с git. В некоторых случаях при этом обновлении часть зеркал для устаноки используются некорректно. Я пока не стал бороться с обновлениями, а просто решил использовать заведомо шустрые зеркала.

- [Как обновлять список зеркал](https://antergos.com/wiki/uncategorized/how-to-choose-your-mirrors-before-installing-antergos/), на [русском](https://antergos.com/wiki/ru/uncategorized/how-to-choose-your-mirrors-before-installing-antergos/) не смотрите, сломаете глаз
- [Как выбирать быстрые зеркала](http://unixa.ru/korotko-o-glavnom-./arch-rankmirrors-ili-delaem-mirrorlist-aktualnyim-i-byistryim.html)
- [Оригинальная документация Arch](https://wiki.archlinux.org/index.php/mirrors)

Проблемы:
- в примере "Как обновлять список зеркал" у меня не не было файла `antergos-mirrorlist.pacnew`
- `rankmirrors` с `antergos-mirrorlist` не заработал. Надо проверить, как ранжируются зеркала в `cnchi`

Скрипты:
- [set-mirrors.sh](../scripts/set-mirrors.sh) - копирует заранее созданные файлы `antergos-mirrorlist` и `mirrorlist`
- [update-mirrors.sh](../scripts/set-mirrors.sh) - попытка автоматизированно получить самые быстрые зеркала.

Не забыть: 
- Установить `chmod +x` скриптам
- При запуске не пересортировывать зеркала. 
- [Yandex](https://yandex.ru/) - спасибо за ультрабыстрые зеркала репозиториев
- Посмотреть, можно ли в cnchi оптимизировать загрузку и отремонтировать прогресс-бар

#### Разбить диск

Дальше надо разбить диск. Тут в установке есть одна интересная хитрость. Я активно пользуюсь несколькими ОС, в том числе не могу снести Windows. У меня в системном блоке несколько HDD и SSD. А так как мне всё равно придётся настраивать мультизагрузку, и Linux вполне переживает загрузку то в VM, то в железе, то есть смысл подключить **физический** диск (SSD) в VirtualBox и там уже устанавливать. Плюсов тут несколько: 
- Пока устанавливается ОС можно ~~подрочить~~ спокойно заниматься своими делами. 
- Если что-то пошло не так, можно загуглить проблему или заранее подготовить скрипты (как собственно, я сейчас и делаю)
- Установщик не имеет шансов запоганить загрузку остального зоопарка. После установки придётся настраивать мультизагрузку, но с этим проще бороться, когда лишь одна из трёх систем не грузится, а не когда ничего не работает.
- Загрузка и установка с образа на HDD/SSD быстрее чем с флэшки и уж тем более с DVD (что такое DVD???). Это важно, потому что cnchi устанавливается неспешно.

Добрые советы:
- При работе с физическим диском VirtualBox в Windows придётся запускать из-под администратора.
- НЕ ВКЛЮЧАЙТЕ кеширование IO диска в настройках виртуальной машины. Если придётся снимать процесс VM, то есть неплохие шансы убить файловую систему.
- НЕ ИСПОЛЬЗУЙТЕ сохранение состояния и снимки. Так тоже можно убить файловую систему (забыл, что виртуальную машину не выключил, а засуспендил, загрузился с диска и привет - так я однажды и сделал).
- Вам в случае такой установки нужно будет отдельно устанавливать некоторые драйвера после установки.   

В любом случае у меня несколько дисков, часть из них hdd, часть ssd, а есть еще диск загрузки. Для того, чтобы посмотреть, какие диски у нас есть использую `lsblk`. Так выглядит в VM
```
$ lsblk                                             
NAME  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
loop0   7:0    0  1.8G  1 loop /run/archiso/sfs/root-image
sda     8:0    0  128G  0 disk 
sr0    11:0    1  1.9G  0 rom  /run/archiso/bootmnt
```

Дальше я считаю, что тот самый диск, на который ставим систему - sda. Для однократной разбивки можно было бы пользоваться `gparted`, но я хочу сделать воспроизводимую установку. Так что только `parted`. 

1. Два раза проверяю, что диск именно тот. Мы сейчас собираемся его очистить. 
2. На диске создаём таблицу разделов gpt.
3. Создаём раздел с `bios_grub`. Например, установщик Antergos, если делать разбивку вручную, заботливо предупреждает **"GRUB требует, чтобы загрузочный раздел в BIOS системах содержал файл core.img из-за отсутствия пропуска после таблицы в GPT дисках.
Cnchi создаст этот загрузочный раздел BIOS за вас.".** Подробнее [тут](https://wiki.archlinux.org/index.php/GRUB_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)). Если не вручную, то раздел с `bios_grub` стоит сделать самому.
3. Кроме `bios_grub` я создаю:
- swap (примерно с память размером)
- boot - ext4 - 4 ГБ, хотя это весьма избыточно
- root - btrfs - именно тут будет работать snapper
- home - btrfs
4. Заскриптовано [тут](./scripts/init-disk.sh)
5. Тут я столкнулся с [печалькой](https://github.com/Antergos/Cnchi/issues/812). Приходится делать какие-то лишние ручные действия.

Дальше устанавливаем ОС.

Подгоним разбивку root-раздела под снимки

#### Прочие мелочи

- `cfdisk` - терминальная альтернатива `gparted`
- `lsof` - что ггде открыто
- swap-файл на btrfs не положить. Поэтому - раздел.
- без boot можно обойтись. теоретически. 


##### Жирные пакеты в AUR 

Пакеты в AUR иногда большие. Очень большие. А `/tmp` в памяти и ограничен. [Опции](https://archlinuxarm.org/forum/viewtopic.php?f=57&t=8812):
- Увеличить `/tmp`
- Собирать не в tmp
    
##### chmod+x в Windows 

При написании этих скриптов возникла проблемочка: писал я их частично в Windows, а в этом случае они прилетали в репозиторий не как выполняемые файлы.

Решение
```
> git add .
> git ls-files --stage
100644 012c4ba239ecdbd15c70c05b9306c32175dc8c5c 0       file.sh
> git update-index --chmod=+x file.sh
> git commit -m "executable"
[master c6e8134] executable
 1 files changed, 1 insertions(+), 1 deletion(-)
 mode change 100644 => 100755 scripts/file.sh
> git ls-files --stage
100755 012c4ba239ecdbd15c70c05b9306c32175dc8c5c 0       file.sh
```





